# Raft Extended (2) 课程笔记

## 5.4.1 选举限制

不能仅仅用日志最长的服务器作为 leader。

Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。

## 快速恢复

follower 和 leader 的日志冲突时，会返回：

xTerm： 冲突的日志的任期。

xIndex：任期是 xTerm 的第一个日志索引。

xLen：follower 的日志长度。

#### 例子

case 1：

s1 4 5 5

s2 4 6 6 6

case 2:

s1 4 4 4

s2 4 6 6 6

case 3:

s1 4

s2 4 6 6 6

case1 leader s2 没有任期为 5 的日志，s1 返回 xTerm = 5, xIndex = 2。 s2 就可以将 nextIndex\[s1] 设置为 xIndex，下一次发送给 s1 的 prevLogIndex 和 prevLogTerm 就能和 s1 匹配上了。

## 持久化

需要持久化的字段：

log，currentTerm，votedFor

## 快照

raft 会选择一个时间点，将之前的状态作为快照保存到磁盘，然后删除该时间点之前的所有日志，以节省内存空间。

通过 install snapshot rpc，leader 会发送当前的快照和快照之后的日志给 followers 来同步。

## 线性一致

我们对于正确的定义就是线性一致（Linearizability）或者说强一致（Strong consistency）。通常来说，线性一致等价于强一致。一个服务是线性一致的，那么它表现的就像只有一个服务器，并且服务器没有故障，这个服务器每次执行一个客户端请求，并且没什么奇怪的是事情发生。

一个系统的执行历史是一系列的客户端请求，或许这是来自多个客户端的多个请求。如果执行历史整体可以按照一个顺序排列，且排列顺序与客户端请求的实际时间相符合，那么它是线性一致的。当一个客户端发出一个请求，得到一个响应，之后另一个客户端发出了一个请求，也得到了响应，那么这两个请求之间是有顺序的，因为一个在另一个完成之后才开始。一个线性一致的执行历史中的操作是非并发的，也就是时间上不重合的客户端请求与实际执行时间匹配。并且，每一个读操作都看到的是最近一次写入的值。

![](<../../.gitbook/assets/raft\_3 (1) (1).png>)

这里可以这么理解，左边是一个多副本系统的输入输出，因为分布式程序或者程序的执行，产生了这样的时序，但是在一个线性一致的系统中，实际是按照右边的顺序执行的操作。左边是实际时钟，右边是逻辑时钟。

所以这里有个顺序且符合前面两个限制条件，所以执行历史是线性一致的。如果我们关心一个系统是否是线性一致的，那么这个例子里面的输入输出至少与系统是线性一致的这个假设不冲突。
