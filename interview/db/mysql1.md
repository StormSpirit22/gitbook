## MySQL 索引

#### **按数据结构索引可以分为以下几类：**

- **B+树索引**：
   通过树形结构存储数据，适用于范围查询（如 `BETWEEN`）和精确查询（如 `=`），支持有序数据的快速查找、排序和聚合操作。是 MySQL 默认的索引类型，常用于 **InnoDB** 和 **MyISAM** 引擎。
- **哈希索引**：
   基于哈希表的结构，适用于**等值查询**（如 `=`），查询速度非常快，但**不支持范围查询**（如 `<`、`>`）。哈希索引不存储数据的顺序，常用于 **Memory** 引擎。
- **倒排索引（Full-Text）**：
   用于全文搜索，将全文分词，通过存储词与文档的映射，支持模糊匹配和关键词搜索。特别适合用于**大文本字段**，如 `TEXT` 类型的列，可查找包含特定词语的记录。
- **R-树索引**：
   专为多维空间数据（如**地理坐标**）设计，适用于**空间查询**（例如计算地理位置的最近距离、区域查询等）。常用于存储和查询**地理信息系统（GIS）**中的空间数据。



### MySQL 为什么用 B+ 树做索引？

![image-20250214161622669](/Users/zonst/Library/Application Support/typora-user-images/image-20250214161622669.png)

B 树与 B+ 树的最大区别就是，B 树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中，

1、B+**树的层级更少**：相较于B树或红黑树，B+树非叶子节点仅保存主键或索引值和页面指针，每一页可以容纳更多记录，内存中能存放更多索引，容易命中缓存，查询磁盘 I/O 次数也减少；

2、B+**树天然具备排序功能**：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

3、B+**树全节点遍历更快**：B+树的叶子节点通过链表连接，遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做[全表扫描](https://www.zhihu.com/search?q=全表扫描&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A27700617})。



#### **InnoDB B+ 树索引可以分为：**

- **聚簇索引（Clustered Index）**：
   InnoDB **主键索引**就是**聚簇索引**。它基于主键排序存储。之所以叫聚簇索引，是因为**叶子节点存储完整的数据行**。

- **非聚簇索引（Non-clustered Index，Secondary Index）**：
   指的是 InnoDB **非主键索引**，也叫**辅助索引**。这种索引的叶子节点**仅存储索引字段和主键值**，如果要查询完整的数据行，需要**再次从聚簇索引中通过主键查询**，这就是**回表**。一个表可以有多个非聚簇索引。

  ![image-20250213143812460](/Users/zonst/Library/Application Support/typora-user-images/image-20250213143812460.png)

​	上图展示了一个使用辅助索引查找一条表记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录，这也是通常情况下行记录的查找方式。

如果 sql 是

```sql
select first_name, age, id from users where first_name="Jones" and age <= 30
```

则不需要回表，这种不需要回表查询的二级索引就叫**覆盖索引**。

### 

#### **从索引性质的角度来看，可以分为：**

- **普通索引**：
   一般指非主键索引，**非唯一索引**。每个表只能有**一个主键索引**，但可以有多个普通索引。
- **主键索引**：
   表中每一行数据都拥有唯一的**主键**，且**主键不能为 NULL**。InnoDB 中的主键索引是基于**聚簇索引结构**实现的。
- **联合索引**：
   由**多个列**组成的索引，适用于多列的查询条件，能提高包含多个条件的查询的性能。联合索引中的列是**按指定顺序排列**的。
- **唯一索引**：
   **保证索引列的值是唯一的**，可以有效防止重复数据插入。唯一索引允许 `NULL` 值，但**一个列中可以有多个 `NULL`**。
- **全文索引**：
   用于**全文搜索**，支持对**文本字段（如 `TEXT` 类型）进行关键字查询，支持自然语言处理**、**模糊匹配等**。适用于需要对文本内容进行复杂搜索的场景。



## 联合索引

### 最左匹配原则

MySQL 索引的最左前缀匹配原则指的是在使用联合索引时，查询条件必须从索引的最左侧开始匹配。如果一个联合索引包含多个列，查询条件必须包含第一个列的条件，然后是第二个列，以此类推。

联合索引在 B+ 树中的排列方式遵循"从左到右”的顺序。例如，联合索引 `(first_name, last_name, age)` 会按照 `(first_name, last_name, age)` 的顺序在 B+ 树中进行排序。MySQL 在查找时会优先使用 `first_name` 作为匹配依据，然后依次使用 `last_name` 和 `age`。因此，组合索引能够从左到右依次高效匹配，跳过最左侧字段会导致无法利用该索引。

假设当前表有一个联合索引 `(a, b, c)`。以下查询条件**不符合**最左匹配原则：

```sql
WHERE b=2;
WHERE c=3;
WHERE b=2 AND c=3;
```

再来看下这个查询：

```sql
WHERE a=1 AND c=3;
```

这个查询可能可以用上联合索引 `(a, b, c)`。在 MySQL 5.6 版本之前，即使用上也只能利用 `a=1` 这个条件来过滤。但是在 MySQL 5.6 版本后有个优化，即索引下推，可以在引擎层面，查询得到 `a=1` 的数据之后，利用 `c` 过滤掉不符合的数据，再返回给 server 层。

如果遇到范围查询（`>`、`<`），就会停止匹配。例如：

```sql
WHERE a>1 AND b=2 AND c=3;
```

所谓的停止匹配指的是：`a` 可以用上联合索引，但是 `b` 和 `c` 却不行。因为 `a` 需要先经过范围查询，此时经过筛选得到 `b` 和 `c` 的数据是无序的。

如果遇到如 `>=`、`<=`、`BETWEEN`、前缀 `LIKE`（`xx%`）的范围查询，则不会停止匹配。因为这些查询包含一个等值判断，可以直接定位到某个数据，然后往后扫描即可。

### 索引下推

![MySQL大概架构](https://gitee.com/sanfene/picgo3/raw/master/20210908213037.png)

`索引下推`的**下推**其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。MySQL5.6版本的新特性，它能减少回表查询次数，提高查询效率。

我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：

- 存储引擎读取索引记录；
- 根据索引中的主键值，定位并读取完整的行记录；
- 存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件。

使用ICP的情况下，查询过程：

- 存储引擎读取索引记录（不是完整的行记录）；
- 判断`WHERE`条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；
- 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
- 存储引擎把记录交给`Server`层，`Server`层检测该记录是否满足`WHERE`条件的其余部分。

#### 举例

假设当前 people 表有索引 `(zipcode, lastname, firstname)`，当执行以下查询时：

```sql
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
```

如果没有索引下推，当前的联合索引只能用上 `zipcode='95054'` 这个条件，引擎层用不上 `lastname` 这个条件过滤，只能得到所有符合 `zipcode='95054'` 记录，传递给 server 层过滤。 

有了索引下推之后，引擎层在得到符合 `zipcode='95054'` 的数据后，可以直接通过 `lastname` 条件过滤数据，不符合条件的不会返回给 server 层。

#### 索引下推注意点 

1. 索引下推在 MySQL 5.6 及以后的版本支持，`InnoDB` 和 `MyISAM` 这两个存储引擎都生效。 
1. 如果查询中引用了子查询，索引下推可能不会生效，具体可以通过 `EXPLAIN` 进行分析。 
1.  使用了函数或表达式，索引下推也不能生效，这个与是否能命中索引的条件类似。
1.  使用了聚簇索引查询，索引下推不会生效，**因为索引下推的目的是为了减少回表次数，也就是要减少IO操作**。对于`InnoDB`的聚簇索引来说，数据和索引是在一起的，不存在回表这一说。
1. 索引条件下推默认是开启的，可以使用系统参数`optimizer_switch`来控制器是否开启。



