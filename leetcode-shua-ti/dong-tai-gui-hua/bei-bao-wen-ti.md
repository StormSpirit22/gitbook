---
description: 经典的背包问题
---

# 背包问题

背包问题大家应该都听过吧，可能刚开始接触会觉得很难，但是我们之前已经做过了很多dp的问题，只要仔细分析然后套路就行。你会发现并没有那么难。

本文要分析的题目：

[背包问题（二）（中等）](https://www.lintcode.com/problem/125/)

[分割等和子集（中等）](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

[零钱兑换 II（中等）](https://leetcode-cn.com/problems/coin-change-2/)

## 题目解析

### 背包问题

> 有 `n` 个物品和一个大小为 `m` 的背包. 给定数组 `A` 表示每个物品的大小和数组 `V` 表示每个物品的价值
>
> 问最多能装入背包的总价值是多大?

解析：

经典问题 0-1 背包问题，这道题 leetcode 上没有，只有从别的地方看了。大致解释一下意思，就是给一个容量为 m 的背包，有 n 个物品，每个物品的占用容量和价值都用一个数组表示，求该背包能容纳的物品的最大价值。

求最值的问题一般都是用 dp 来做。首先想一下我们的 dp 数组的意思。

这里有物品和背包容量两个状态：**分别是物品放或者不放，背包容量有多少**。而总价值应该是 dp 数组的结果。

我们假设 dp\[i]\[j] 的意思为，**在前 i 个物品内，容量为 j 的背包能容纳物品的最大价值为多少**。

那么 base case 是`dp[0][...] = dp[...][0] = 0`，即如果物品为 0 或者容量为 0 那么价值肯定为 0。

再想状态转移方程，物品 i 有放或者不放两种状态，我们就是求这两种状态的最大值。

可以想出：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-A[i-1]] + V[i-1])`。意思是：

**如果你没有把这第`i`个物品装入背包**，那么很显然，最大价值`dp[i][j]`应该等于`dp[i-1][j]`。你不装嘛，那就继承之前的结果。

**如果你把这第`i`个物品装入了背包**，那么`dp[i][j]`应该等于`dp[i-1][j-A[i-1]] + V[i-1]`。

首先，由于`i`是从 1 开始的，所以对`V`和`A`的取值是\*\*`i-1`\*\*。

而`dp[i-1][j-A[i-1]]`也很好理解：你如果想装第`i`个物品，你怎么计算这时候的最大价值？换句话说，在装第`i`个物品的前提下，背包能装的最大价值是多少？

显然，你应该寻求剩余重量`j-A[i-1]`限制下能装的最大价值，加上第`i`个物品的价值`V[i-1]`，这就是装第`i`个物品的前提下，背包可以装的最大价值。

这样问题就解决啦，要注意的是数组容量大小应该是m+1和n+1，因为是从0开始到m和n的。

### 分割等和子集

> 给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\\

解析：

先求出数组的和，如果是奇数，那么就不可能分割成两个元素和相等的子集。如果是偶数就继续用 dp 的办法。

可以把这题理解为背包问题，对于一个容量为 sum/2 的背包，在nums里能否找到一部分数据刚好是能填满这个背包， 即加起来的和为 sum/2，（那么另一部分数据加起来肯定也正好等于 sum/2 ，这个应该懂吧？）。

根据 0-1背包的思路，**设 `dp[i][j]` 为在前i个数中，对于容量为 j 的背包是否能刚好填满。**

比如 `dp[3][5]=true` 的意思是在前 3 个数据中至少有一种方法能够刚好填满容量为 5 的背包，那么最后返回的就是 `dp[n][sum/2]`，即在 nums 里有没有 一种数据组合加起来等于 sum/2。

base case 是`dp[0][...] false, dp[...][0] = true`。当背包容量为 0 时，即在数组中什么数字都不拿就能满足要求，所以`dp[...][0] = true`。

状态就是数字i放进背包或者不放。状态转移方程：`dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]`。

### 零钱兑换 II

> 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
>
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
>
> 假设每一种面额的硬币有无限个。

解析：

可以理解为对于一个容量为 amount 的背包，有 coins 无限不同重量的物品，可以有多少种方法填满背包？

**假设 `dp[i][j]` 为对于前 i 个 coin, 填满j容量的背包有几种方式。**

base case `dp[0][...] = 0, dp[...][0] = 1`

方程 `dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]`。意思是：

**如果你不把这第`i`个物品装入背包**，也就是说你不使用`coins[i]`这个面值的硬币，那么凑出面额`j`的方法数`dp[i][j]`应该等于`dp[i-1][j]`，继承之前的结果。

**如果你把这第`i`个物品装入了背包**，也就是说你使用`coins[i]`这个面值的硬币，那么`dp[i][j]`应该等于`dp[i][j-coins[i-1]]`。

首先由于`i`是从 1 开始的，所以`coins`的索引是`i-1`时表示第`i`个硬币的面值。

`dp[i][j-coins[i-1]]`也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额`j - coins[i-1]`。

比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。

**综上就是两种选择，而我们想求的`dp[i][j]`是「共有多少种凑法」，所以`dp[i][j]`的值应该是以上两种选择的结果之和。**

那么为什么前两题第二种情况都是基于 i - 1 的，而这题却是基于 i 的呢？我理解的也不是很透彻，希望有能说清楚的兄弟在评论区里指出一下。

还有一种方法，来源于官方题解，算是上一种办法的状态压缩。

重新定义一维dp数组, `dp[i]` 为对于amount，表示金额之和等于 i 的硬币组合数，目标是求 dp\[amount]。

动态规划的边界是 `dp[0]=1`。只有当不选取任何硬币时，金额之和才为 0，因此只有 1种硬币组合。

对于面额为coin 的硬币，当 coin≤i≤amount 时，如果存在一种硬币组合的金额之和等于i−coin，则在该硬币组合中增加一个面额为 coin 的硬币，即可得到一种金额之和等于 i 的硬币组合。

因此需要遍历 coins，对于其中的每一种面额的硬币，更新数组 dp 中的每个大于或等于该面额的元素的值。即方程为`dp[i] = dp[i] + dp[i-1]`

## 代码

### 背包问题

```go
func backPackII (m int, A []int, V []int) int {
	n := len(A)
	dp := make([][]int, n+1)
	for i := 0; i < n+1; i++ {
		dp[i] = make([]int, m+1)
	}

	for i := 1; i < n+1; i++ {
		for j := 1; j < m+1; j++ {
			if j >= A[i-1] {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-A[i-1]] + V[i-1])
			} else {
				dp[i][j] = dp[i-1][j]
			}
		}
	}
	return dp[n][m]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 分割等和子集

```go
func canPartition(nums []int) bool {
    sum := 0
    for i := range nums {
        sum += nums[i]
    }
    if sum % 2 != 0 {
        return false
    }
    m := sum / 2
    n := len(nums)
    //放入背包的数字可以放0个、1个到n个，所以长度为n+1
    dp := make([][]bool, n+1)
    for i := 0; i < n+1; i++ {
        //背包容量可以从0-m
        dp[i] = make([]bool, m+1)
        dp[i][0] = true
    }
    for i := 1; i < n+1; i++ {
        for j := 1; j < m+1; j++ {
            //背包容量大于当前数字
            if j >= nums[i-1] {
                dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[n][m]
}
```

### 零钱兑换II

```go
func change(amount int, coins []int) int {
    n := len(coins)
    dp := make([][]int, n+1)
    for i := 0; i < n+1; i++ {
        dp[i] = make([]int, amount+1)
        dp[i][0] = 1
    }

    for i := 1; i < n+1; i++ {
        for j := 1; j < amount+1; j++ {
            //i = 1的时候其实是coints[0]，即选出第一个coin的意思
            if j >= coins[i-1] {
                dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[n][amount]
}
```

```go
func change(amount int, coins []int) int {
    dp := make([]int, amount+1)
    dp[0] = 1
    for _, coin := range coins {
        for i := coin; i <= amount; i++ {
            dp[i] += dp[i-coin]
        }
    }
    return dp[amount]
}
```
