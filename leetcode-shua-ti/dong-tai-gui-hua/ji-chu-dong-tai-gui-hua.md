---
description: 介绍一些最简单的动态规划
---

# 动态规划基础

本文会介绍一些最基础最简单的动态规划题，让大家有个循序渐进的过程。

首先对于动态规划的问题，最重要的有四点：

**dp数组或dp函数的意思。**

**dp的 base case是什么。**

**dp的状态。**

**dp状态转移方程是什么。**

状态转移方程可以从它的子问题中去寻找，比如对于状态 i，和 i-1有没有关系。然后对于每个状态进行遍历，比如：

```go
for i in 状态1
    for j in 状态2
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

对于每道题，搞清楚这几点做题就很容易了。都是套路，只要多做多总结就好。

本文要介绍的题目有：

[斐波那契数（简单）](https://leetcode-cn.com/problems/fibonacci-number/)

[爬楼梯（简单）](https://leetcode-cn.com/problems/climbing-stairs/)

## 题目解析

### 斐波那契数

> **斐波那契数**，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> ```
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> ```
>
> 给你 `n` ，请计算 `F(n)` 。

解析：

这题应该是最经典的一道动态规划题了，其实不知道动态规划是啥的人也能很容易做出来这道题。我们就用动态规划的套路来做一做这道题。

这题其实已经告诉我们dp数组的意思，dp\[i]就是第 i 个斐波那契数。

base case 就是`dp[0] = 0，dp[1] = 1`，状态就是第几个斐波那契数的改变。

状态转移方程也给我们了， `dp[i] = dp[i-1] + dp[i-2]`，所以我们要做的就是对 i 进行遍历。

当然在本题中，因为 i 只和它前 2 个元素状态有关，所以我们不需要用dp数组存储其他不必要的数据，可以进行状态压缩。不过这不是特别关键，重要的是我们要在这类简单的题里了解动态规划的思路和套路。

### 爬楼梯

> 假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

解析：

这题其实和上题是差不多的。设dp\[i]为对于 i 级楼梯，爬到楼顶的方法数。

base case `dp[0] = 0，dp[1] = 1，dp[2] = 2`。

状态转移方程 `dp[i] = dp[i-1] + dp[i-2]，`意思是对于爬上第 i 级阶梯的方法数是等于 爬上 i - 1和爬上 i - 2 级阶梯的方法数之和，其实很好理解，对于第 i 级阶梯，要么就是从 i - 1 再爬1个台阶上来，要么就是从 i - 2 级台阶再爬2个台阶上来，没有别的办法。

这也就是“状态”转移，这题的状态就是爬上的台阶数， 可以由其他的台阶数转移过来。既然转移方程和上题一样，当然也可以用状态压缩。

## 代码

### 斐波那契数

```go
func fib(n int) int {
    if n < 2 {
        return n
    }
    p, q, r := 0, 0, 1
    for i := 2; i <= n; i++ {
        p = q
        q = r
        r = p + q
    }
    return r
}
```

### 爬楼梯

```go
func climbStairs(n int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2
    for i := 3; i < n+1; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

```go
func climbStairs(n int) int {
    p, q, r := 0, 0, 1
    for i := 1; i <= n; i++ {
        p = q
        q = r
        r = p + q
    }
    return r
}
```

## 总结

做了这几道题之后是不是对dp有了一个初步的认识？其实这类题目就是和开头说的一样，找到那几点，最重要的是方程，我们可以先思考状态 i 是不是和它的子集有关系，方程想出来了就简单了，之后遍历就行了。
