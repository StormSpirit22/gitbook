# 贪心问题

这次来看看贪心问题，这类问题其实是另类的动态规划。

本文要介绍的题：

[跳跃游戏（中等）](https://leetcode-cn.com/problems/jump-game/)

[跳跃游戏 II（中等）](https://leetcode-cn.com/problems/jump-game-ii/)

## 题目解析

### 跳跃游戏

> 给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标。

解析：

贪心算法，根据每一步的值计算出能跳跃到的最右边的位置 (rightMax)，即 `i+nums[1]`。

比如在第 0 步，值为 2 ，那么此时能跳跃到的最右边的值即为索引为 2 的位置。

所以用当前索引与 rightMax 比较就可以判断是否可以到达，如果当前位置的索引小与 rightMax 那么就代表到达不了该位置，或者`rightMax > n-1`那么直接返回 true 即可。

### 跳跃游戏II

> 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> 假设你总是可以到达数组的最后一个位置。

解析：

对于每个位置我们都去更新一下当前能跳跃到的最大位置，记为边界。

我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1，最后返回跳跃次数。

要注意的是遍历的索引应该从 0 到 length-2 ，数组最后一个值不需要处理，因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。

如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。

## 代码

### 跳跃游戏

```go
func canJump(nums []int) bool {
    n := len(nums)
    rightMax := 0
    for i := 0; i < n; i++ {
        if i <= rightMax {
            rightMax = max(rightMax, i + nums[i])
        } else {
            return false
        }
        if rightMax >= n-1 {
            return true
        }
    }
    return false
}
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 跳跃游戏II

```go
func jump(nums []int) int {
    //在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，
    // 否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，
    // 我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素
    n := len(nums)-1
    //跳跃步数
    steps := 0
    //上次跳跃的右边界位置（下次的最右起跳点）
    end := 0
    //当前能跳跃的最远位置
    maxFar := 0
    for i := 0; i < n; i++ {
        maxFar = max(maxFar, i + nums[i]) //找到当前能跳跃到的最大位置
        // 到达上次跳跃能到达的右边界了
        if i == end {
            end = maxFar // 目前能跳到的最远位置变成了下次起跳位置的有边界
            steps++        // 进入下一次跳跃
        }
    }
    return steps
}


func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```
