# 消息队列篇

## 秒杀时如何处理每秒上万次的下单请求

秒杀抢购就是最典型的高并发写请求的场景。

在秒杀开始之前大部分都是读请求，而且用户查询的是少量的商品数据，属于 **查询的热点数据** ，可以采用缓存策略，将请求尽量挡在上层的缓存中，能被静态化的数据，比如说商城里的图片和视频数据，**尽量做到静态化，这样就可以命中 CDN 节点缓存** ，减少 Web 服务器的查询量和带宽负担。Web 服务器比如 Nginx 可以直接访问分布式缓存节点，这样可以避免请求到达业务服务器。

当然，还可以加上一些限流的策略，比如，对于短时间之内来自某一个用户、某一个 IP 或者某一台设备的重复请求做丢弃处理。

通过这几种方式，就可以将请求尽量挡在数据库之外了。

秒杀开始之后，可以通过以下几种方式来应对高并发的写请求。

### 削去秒杀场景下的峰值写流量

将秒杀请求暂存在消息队列中，然后业务服务器会响应用户 「秒杀结果正在计算中」，释放了系统资源之后再处理其它用户的请求。

后台启动若干个队列处理程序，消费消息队列中的消息，再执行校验库存、下单等逻辑。**因为只有有限个队列处理线程在执行，所以落入后端数据库上的并发请求是有限的** 。而请求是可以在消息队列中被短暂地堆积， **当库存被消耗完之后，消息队列中堆积的请求就可以被丢弃了** 。

![img](https://zq99299.github.io/note-architect/assets/img/de0a7a65a0bf51e1463d40d666a034ad.de0a7a65.jpg)

### 通过异步处理简化秒杀请求中的业务流程

将业务逻辑分成主要逻辑和次要逻辑，分开处理。比如下图先处理核心的订单业务逻辑，然后将消息继续放到消息队列里，等待其他的业务逻辑继续消费执行，不占用主要逻辑的时间。

![img](https://zq99299.github.io/note-architect/assets/img/3b19c4b5e93eeb32fd9665e330e6efaa.3b19c4b5.jpg)

### 解耦实现秒杀系统模块之间松耦合

将业务系统和数据系统解耦。比如下图中业务处理之后再把数据放到消息队列中供数据服务消费处理。

![img](https://zq99299.github.io/note-architect/assets/img/6e096e287f2c418f663ab201f435a5f6.6e096e28.jpg)

### 总结

- 削峰填谷是消息队列最主要的作用， **但是会造成请求处理的延迟** 。
- 异步处理是提升系统性能的神器，但是你需要分清同步流程和异步流程的边界，同时消息存在着丢失的风险，我们需要考虑如何确保消息一定到达。
- 解耦合可以提升你的整体系统的鲁棒性。