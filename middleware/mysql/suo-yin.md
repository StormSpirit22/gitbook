# 索引

参考

[MySQL 索引设计概要](https://draveness.me/sql-index-intro/)

[MySQL索引有哪些分类，你真的清楚吗？](https://segmentfault.com/a/1190000037683781)

## 索引类型

### 按数据结构分类

可分为：**Hash 索引、B 树索引、B+ 树索引**。

#### Hash 索引

的检索可以一次定位，所以 Hash 索引的查询效率要远高于 B-Tree 索引。但是对于处理**范围查询或者排序**性能会非常差，只能进行全表扫描并依次判断是否满足条件。因为哈希函数的目的就是让数据尽可能被分散到不同的桶中进行存储，无法排序，可能 id 相近的两条数据被分配到两个不同的桶内。

#### B+ 树

![](<../../.gitbook/assets/index-1 (1).png>)

B 树与 B+ 树的最大区别就是，B 树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中，

1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+**树天然具备排序功能：B+树所有的叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+**树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做[全表扫描](https://www.zhihu.com/search?q=%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F\&search\_source=Entity\&hybrid\_search\_source=Entity\&hybrid\_search\_extra={%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A27700617})。

B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；

#### 红黑树

![An example of a red-black tree](../../.gitbook/assets/index-10.png)

红黑树可参考 [30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)。

### 按物理存储分类

可分为：**聚簇索引、二级索引（辅助索引）**。

#### 聚簇索引

就是以表的主键作为索引，比如 PRIMARY KEY(id), 就会根据 id 的顺序构建一颗 B+ 树，并在叶节点中存放表中的**行记录数据**。聚集索引叶节点中保存的是**整条行记录**，而不是其中的一部分。所有正常的表应该**有且仅有一个**聚集索引。

#### 辅助索引

也是通过 B+ 树实现的，但是它的节点仅包含索引中的列数据和主键数据。

需要注意的是，**通过辅助索引查询时，回表不是必须的过程**，当**SELECT的所有字段在单个辅助索引中都能够找到**时，就不需要回表，MySQL称此时的二级索引为**覆盖索引**或触发了**索引覆盖**。

### 按字段特性分类

可分为：**主键索引、普通索引、前缀索引**。

#### 主键索引

建立在主键上的索引被称为**主键索引**，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。

#### 唯一索引

建立在UNIQUE字段上的索引被称为**唯一索引**，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。

#### 普通索引

建立在普通字段上的索引被称为**普通索引**。

#### 前缀索引

**前缀索引**就是基于原始索引字段，截取前面指定的字符个数或者字节数来做的索引。而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。

具体可以查看 [第20期：索引设计（前缀索引）](https://opensource.actionsky.com/20210120-mysql/)

### 按字段个数分类

可分为：**单列索引、联合索引**。

#### 单列索引

建立在单个列上的索引被称为单列索引。

#### 联合索引

建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。

## 索引基础

数据库查询操作的时间大都消耗在从磁盘或者内存中读取数据的过程，由于随机 IO（一次大概要 10 ms） 的代价巨大，如何在一次数据库查询中减少随机 IO 的次数往往能够大幅度的降低查询所耗费的时间提高磁盘的吞吐量。

数据页面的顺序读取有两个非常重要的优势：

1. 同时读取多个界面意味着总时间的消耗会大幅度减少，磁盘的吞吐量可以达到 40MB/s；
2. 数据库管理程序会对一些即将使用的界面进行预读，以减少查询请求的等待和响应时间；

### 索引片（Index Slices）

就是 SQL 查询在执行过程中扫描的一个索引片段，在这个范围中的索引将被顺序扫描。

![](../../.gitbook/assets/index-2.png)

**宽索引**包含了所需的数据列不需要回表，**窄索引**没有包含 sql 查询的所有列就需要回表。

宽索引能够避免二次的随机 IO，而窄索引就需要在对索引进行顺序读取之后再根据主键 id 从主键索引中查找对应的数据：

![Thin-Index-and-Clustered-Index](../../.gitbook/assets/index-9.png)

**对于窄索引，每一个在索引中匹配到的记录行最终都需要执行另外的随机读取从聚集索引中获得剩余的数据**，如果结果集非常大，那么就会导致**随机读取的次数过多**进而影响性能。

### 过滤因子

过滤因子就是作为索引的列。比如 sex 这一列，只有男女两类数据，就不是一个好的过滤因子。所以**在一般情况下**我们最好不要使用 sex 列作为整个索引的第一列。而 name=“draven” 的使用就可以得到一个比较好的过滤因子了，它的使用能过滤整个数据表中 99.9% 的数据；当然我们也可以将这三个过滤进行组合，创建一个新的索引 (name, age, sex) 并同时使用这三列作为过滤条件：

![](../../.gitbook/assets/index-3.png)

当三个过滤条件都是等值谓词时，几个索引列的顺序其实是无所谓的，索引列的顺序不会影响同一个 SQL 语句对索引的选择，也就是索引 (name, age, sex) 和 (age, sex, name) 对于上图中的条件来说是完全一样的，这两个索引在执行查询时都有着完全相同的效果。

### 匹配列与过滤列

匹配列就是等值谓词，过滤列就是其他。比如以下 sql：

```sql
SELECT * FROM users
WHERE name = "draven" AND sex = "male" AND age > 20;
```

name 和 sex 就是匹配列，age 就是过滤列。

![](<../../.gitbook/assets/index-4 (1).png>)

## 索引的设计

### 三星索引

如果一个查询语句的索引是三星索引，那么它只需要进行**一次磁盘的随机读及一个窄索引片的顺序扫描**就可以得到全部的结果集；

为了满足三星索引中的三颗星，我们分别需要做以下几件事情：

1. 第一颗星需要取出所有**等值谓词**中的列，作为索引开头的最开始的列（任意顺序）；
2. 第二颗星需要将 ORDER BY 列加入索引中；
3. 第三颗星需要将查询语句剩余的列全部加入到索引中；

![](../../.gitbook/assets/index-5.png)

三颗星的作用：

1. 第一颗星是减少索引片的大小以减少需要扫描的数据行；尽量缩短将要被扫描的叶子节点范围。（如果与一个查询相关的索引行是相邻的，或者至少相距足够靠近的话，就最小化了必须扫描的索引片的宽度。即，把 WHERE 后的等值条件列作为索引最开头的列，如此，必须扫描的索引片宽度就会缩至最短。）
2. 第二颗星用于避免排序，减少磁盘 IO 和内存的使用。
3. 第三颗星用于避免回表。

![](../../.gitbook/assets/index-6.png)

比如以下 sql：

```sql
SELECT id, name, age FROM users
WHERE age BETWEEN 18 AND 21
  AND city = "Beijing"
ORDER BY name;
```

在上述查询中，我们总可以通过增加索引中的列以获得第三颗星，但是如果我们想要获得第一颗星就需要最小化索引片的大小，这时索引的前缀必须为 (city, age)，在这时再想获得三颗星就不可能了，哪怕在 age 的后面添加索引列 name，也会因为 name 在范围索引列 age 后面必须进行一次排序操作，最终得到的索引就是 (city, age, name, id)：

（比如下图还要对 name 这个列进行额外排序。）

![](../../.gitbook/assets/index-8.png)

![Different-Stars-Index](../../.gitbook/assets/index-11.png)

如果我们需要在内存中避免排序的话，就需要交换 age 和 name 的位置了，在这时就可以得到索引 (city, name, age, id)，然而这样就不能满足第一颗星了。

当一个 SQL 查询中**同时拥有范围谓词和 ORDER BY 时**，无论如何我们都是没有办法获得一个三星索引的，我们能够做的就是在这两者之间做出选择，是牺牲第一颗星还是第二颗星。

总而言之，在设计单表的索引时，首先把查询中所有的**等值谓词全部取出**以任意顺序放在索引最前面，在这时，如果索引中同时存在范围索引和 ORDER BY 就需要权衡利弊了，希望最小化扫描的索引片厚度时，应该将**过滤因子最小的范围索引列**加入索引，如果希望避免排序就选择 **ORDER BY 中的全部列**，在这之后就只需要将查询中**剩余的全部列**加入索引了，通过这种固定的方法和逻辑就可以最快地获得一个查询语句的二星或者三星索引了。



## 其他

- **负向查询**，主要是指 **not in,<>,not like** 等，因为如果查询条件中只有这类条件，会导致全表扫描。
- **%xxx** 开头的模糊查询，会导致查询无法使用索引，全表扫描。
- `select id from xxxx where from_unixtime(start_day)>='2018-08-14'` 会导致全表扫描，因为在字段前使用了函数。
-   正确写法 `select id from xxxx where start_day>=unix_timestamp('2018-08-14')`
- `select id from xxx where phone = 12345678900` 一般情况下手机号推荐使用 varchar(32) 存储，因为会有地区等属性（+86），如果 phone 是 varchar 上面的写法会触发[隐式转换](https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben)，导致全表扫描，因为 12345678900 是数字类型，Mysql 检测到 phone 这个字段的查询类型是整型，就会全表扫描，将所有行的 phone 转换成整型，然后再做查询处理。（隐式转换的情况下，全表扫描一般是发生在字符类型字段，数字类型一般不会影响执行计划）。可参考 [Mysql 数据类型隐式转换规则](http://lanffy.github.io/2017/05/12/Mysql-Type-Conversion-Expression-Evalution) 。
- `select * from table`
  - 获取不必要的列会增加 cpu、io、net 消耗。
  - 如果有覆盖索引的情况下，会导致无法有效利用覆盖索引。
  - 程序开发过程中容易因为忘记添加、删除字段，导致出现 bug。
- 分片库的场景下，查询不带分片键容易引起查询放大的问题，会造成所有分片做无效查询。
- 还有一些 SQL 规范，包括但不限制于不允许在主库上执行统计 SQL (count\sum)，不允许大表使用 join、子查询，不允许超过 3 个表的 join 查询等。

 
