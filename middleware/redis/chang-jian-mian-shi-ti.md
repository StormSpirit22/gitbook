# 常见面试题

## 缓存穿透、缓存击穿与缓存雪崩

**缓存穿透**是指查询一个不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。

解决方法：

* 在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return。
* 从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值等（这种情况我们一般会将空对象设置一个**较短的过期时间**）。
* 布隆过滤器。利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在return，存在就去查DB刷新KV再return

**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间（可能设置了过期时间），持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

解决方法：

* 设置热点数据永远不过期。

**缓存雪崩**是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方法：

* 在批量往**Redis**存数据的时候，把每个Key的失效时间都加个随机值。
* 设置热点数据永不过期。



### 布隆过滤器

本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 **“某样东西一定不存在或者可能存在”**。

相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。

#### 实现原理

**HashMap 的问题**

讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。

还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。

**布隆过滤器数据结构**

布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：

![img](../../.gitbook/assets/interview-3.png)

如果我们要映射一个值到布隆过滤器中，我们需要使用**多个不同的哈希函数**生成**多个哈希值，**并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：

![img](../../.gitbook/assets/interview-4.png)

Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：

![img](../../.gitbook/assets/interview-5.png)

值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，**说明没有任何一个值映射到这个 bit 位上**，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” **存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。**

这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。

参考 [详解布隆过滤器的原理，使用场景和注意事项](https://zhuanlan.zhihu.com/p/43263751) [5 分钟搞懂布隆过滤器](https://juejin.cn/post/6844904007790673933)

## Redis为何这么快

* Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。
* 数据结构简单，对数据操作也简单。
* 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。
* 使用多路复用IO模型，非阻塞IO。
* 大量的数据结构上的优化, 比如说字符串没有用C语言自带的,而是用自己的Simple Dynamic String。

## Redis和Memcached的区别

* 存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。
* 数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value。而redis支持五种数据类型。
* 使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
* value的大小：redis可以达到1GB，而memcache只有1MB。

## Redis 单线程 or 多线程

redis 4.0 之前，redis 是**完全单线程的**。

redis 4.0 时，redis 引入了多线程，但是**额外的线程只是用于后台处理**，例如：删除对象，核心流程还是完全单线程的。这也是为什么有些人说 4.0 是单线程的，因为他们指的是核心流程是单线程的。

Redis 6.0 之后在网络 IO 处理方面上了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能

## Redis缓存与数据库双写一致性

这里的一致性是指：数据库数据发生更新后，缓存中的数据要和数据库保持一致。

更新数据库有两种方案：

1. **先更新数据库，再删除缓存。**

 对于这种策略，其实是一种设计模式：`Cache Aside Pattern`

![](../../.gitbook/assets/interview-1.png)

**在高并发下不容易出问题，在原子性被破坏时表现不如意。**

如果原子性被破坏了，可能会发生：

* 第一步成功(操作数据库)，第二步失败(删除缓存)，会导致**数据库里是新数据，而缓存里是旧数据**。
* 如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。

**原子性破坏时，删除缓存失败的解决思路**：

* 将需要删除的key发送到消息队列中
* 消费消息，获得需要删除的key
* 不断重试删除操作，直到成功

2. **先删除缓存，再更新数据库。**

**在高并发下表现不如意，在原子性被破坏时表现优异**

高并发场景下的问题：

* 线程A删除了缓存
* 线程B查询，发现缓存已不存在
* 线程B去数据库查询得到旧值
* 线程B将旧值写入缓存
* 线程A将新值写入数据库

**并发下解决数据库与缓存不一致的思路**：

* 将删除缓存、修改数据库、读取缓存等的操作积压到**队列**里边，实现**串行化**。

![](<../../.gitbook/assets/interview-2 (1).png>)

我们可以发现，两种策略各自有优缺点：

- 先删除缓存，再更新数据库

- - 在高并发下表现不如意，在原子性被破坏时表现优异

- 先更新数据库，再删除缓存(`Cache Aside Pattern`设计模式)

- - 在高并发下表现优异，在原子性被破坏时表现不如意



更多面试题参考：

[面试前必须要知道的Redis面试题](https://mp.weixin.qq.com/s?\_\_biz=Mzg2NzA4MTkxNQ==\&mid=2247485078\&idx=1\&sn=725f2169e308ae20de82801f3bc628c5\&source=41#wechat\_redirect)

[全网最硬核 Redis 大厂面试题解析（2021年最新版）](https://jishuin.proginn.com/p/763bfbd57a6d)
